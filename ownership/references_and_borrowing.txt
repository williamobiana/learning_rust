The Problem: Moving is Inconvenient
fn main() {
    let book = String::from("Great Book");
    read_book(book);        // Give book away...read_book() now owns var book 
    // read_book_again(book); // ERROR! Book is gone!...read_book_again() cannot use var book because it is already owned
}

Solution: Borrowing (Lending)
fn main() {
    let book = String::from("Great Book");
    borrow_book(&book);     // Lend the book...& = operator that points to where the data is stored...in this scenario we are pointing to the data in var book
    borrow_book_again(&book); // Can lend again!...because we are only pointing to the data, var book is not owned by anyone
    // Still have the book
}

fn borrow_book(b: &String) {  // & means "borrow"...we have to define the function to read the data from the variable by adding the '&' operator
    println!("Reading: {}", b);
}


---------------------------------------------------------------------------------
& = operator that points to where the data is stored a.k.a borrow a.k.a reference
---------------------------------------------------------------------------------


Two Types of References:
1. Immutable References (&var)
    let s = String::from("hello");
    let r1 = &s;  // Can read but not modify
    let r2 = &s;  // Multiple readers OK
    // r1.push_str("!");  // ERROR! Can't modify &s because it is immutable, even though we are pointing to the data.

2. Mutable References (&mut var)
    let mut s = String::from("hello");
    let r = &mut s;  // Can read and modify
    r.push_str(" world");
    // let r2 = &s;  // ERROR! Can't have other references while mutable ref exists because r already owns &mut s 


The Borrowing Rules (THE BIG RULES):
Rule 1: At any time, you can have EITHER:
    * One mutable reference (&mut)
    * OR many immutable references (&)
    * BUT NOT both at the same time!

Rule 2: References must always be valid
    * (No dangling pointers to freed memory)

Rule 3: When using sequetial borrowing, the memory should be free, else use a clone
    let mut s = String::from("hello");
    let r1 = &s;          // Read-only borrow
    println!("{}", r1);   // Done with r1
    let r2 = &mut s;      // Now mutable borrow OK
    r2.push_str(" world");

Rule 4: Dereferencing means do not reference/borrow rather follow the pointer to the variable where the data is stored
    let x = 5;
    let r = &x;      // r points to x
    let y = *r;      // * means "follow pointer to get value"
    // y = 5

    Dereferencing with modification:
    let mut s = String::from("hello");
    let r = &mut s;
    *r = String::from("world");  // Modify through reference    

    Dereferencing with methods:
    let s = String::from("hello");
    let len1 = s.len();          // Automatically works on &s
    let len2 = (&s).len();       // Same thing, explicit
    let len3 = (*&s).len();      // Also works!    

---------------------------------------------------------------------------------
* = operator that does not reference/borrow rather follows the variable where the data is stored
---------------------------------------------------------------------------------

Rust's Permissions System
Read, Write, Own (RWO)

Immutable reference for reading (&)
let mut v = vec![1, 2, 3];  // v has: R, W, O
let r = &v[0];              // v has: R only (can't write or move)
                            // r has: R, O (can read)
                            // *r has: R only

Mutable reference (&mut)
let mut v = vec![1, 2, 3];  // v has: R, W, O
let mr = &mut v[0];         // v has: NO permissions! Can't use at all
                            // mr has: R, O
                            // *mr has: R, W                                         

Borrowing with Vectors (This is diffrent from Strings)
Think of it like editing a shared document:

    Problem:
        let mut v = vec![1, 2, 3];
        let r = &v[0];            // v loses W, O permissions
        v.push(4);               // ERROR! Can't write while reading
        println!("{}", r);      // OOPS! Might print garbage

    Solution: Read, write and release
        let mut v = vec![1, 2, 3];
        let r = &v[0];    // v loses W, O permissions
        println!("{}", r); // Reading done
        // v regains W, O permissions here
        v.push(4);        // Now writing is OK

Borrow checker:

    Problem:
        let mut v = vec![1, 2, 3];
        let r = &v[0];            // v loses W, O permissions
        v.push(4);               // ERROR! Can't write while reading
        println!("{}", r);      // OOPS! Might print garbage
    logs:
        Line 1: v created with R, W, O permissions
        Line 2: r = &v[0] → v loses W, O permissions
        Line 3: v.push(4) → ERROR! v needs W permission
        Line 4: println! → Would need r, but already errored

Lifetimes: Permissions return when references stop being used
    Solution: Read, write and release
        let mut v = vec![1, 2, 3];
        let r = &v[0];    // v loses W, O permissions
        println!("{}", r); // r's lifetime ends here
        v.push(4);        // v regains W, O permissions here
    Different branches have different lifetimes:
        let mut v = vec![1, 2, 3];
        let r = &v[0];        // v loses W, O

        if condition {
            println!("{}", r); // r used here, v doesn't get W back yet
        } else {
            // r NOT used here, v gets W back immediately!
            v.push(4);        // OK in this branch!
        }